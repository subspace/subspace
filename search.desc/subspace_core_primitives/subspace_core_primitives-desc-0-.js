searchState.loadedDescShard("subspace_core_primitives", 0, "Core primitives for Subspace Network.\nProgress of an archived block.\nArchived history segment after archiving is applied.\nSize of BLAKE3 hash output (in bytes).\nBLAKE3 hash output\nBlock hash in Subspace network.\nBlock number in Subspace network.\nBlockWeight type for fork choice rules.\nWitness for chunk contained within a record.\nThe block has been fully archived.\nErasure coding rate for records during archiving process.\nTried to create with an empty Vec\nFlat representation of multiple pieces concatenated for …\nSize of blockchain history in segments.\nLast archived block\nMax s-bucket index\nMaximum value.\nThe middle of the piece distance field. The analogue of …\nNumber of PoT checkpoints produced (used to optimize …\nNumber of chunks (scalars) within one raw record.\nNumber of chunks (scalars) within one record.\nNumber of pieces in one segment of archived history.\nNumber of raw records in one segment of recorded history.\nNumber of s-buckets contained within one record (and by …\nA Vec&lt;&gt; that enforces the invariant that it cannot be …\nError codes for <code>NonEmptyVec</code>.\nPiece index 1.\nPiece index 1.\nSegment index 1.\nLength of public key in bytes.\nNumber of partially archived bytes of a block.\nA piece of archival history in Subspace Network.\nA piece of archival history in Subspace Network.\nPiece index in consensus\nPiece offset in sector\nProof of space proof bytes.\nProof of space seed.\nProof of time checkpoints, result of proving\nProof of time key(input to the encryption).\nProof of time output, can be intermediate checkpoint or …\nProof of time seed\nA Ristretto Schnorr public key as bytes produced by …\nByte length of a randomness type.\nLength of signature in bytes\nSigning context used for creating reward signatures by …\nType of randomness.\nRaw record contained within recorded history segment …\nRecord contained within a piece.\nRecord commitment contained within a piece.\nRecord witness contained within a piece.\nRecorded history segment before archiving is applied.\nA Ristretto Schnorr signature as bytes produced by …\nS-bucket used in consensus\nSize in bytes.\nSize of raw record in bytes, is guaranteed to be a …\nSize of a segment record given the global piece size (in …\nSize of record commitment in bytes.\nSize of record witness in bytes.\nSize of chunk witness in bytes.\nSize of a piece (in bytes).\nSize of segment commitment in bytes.\nSize of recorded history segment in bytes.\nSize of archived history segment in bytes.\nSize of proof of space seed in bytes.\nSize of proof of space proof in bytes.\nSize of proof of time key in bytes\nSize of proof of time seed in bytes\nSize of proof of time proof in bytes\nData structure representing sector ID in farmer’s plot\nSector index in consensus\nChallenge used for a particular sector for particular slot\nSegment commitment contained within segment header.\nSegment header for a specific segment.\nSegment index type.\nSlot number in Subspace network.\nFarmer solution for slot challenge.\nType of solution range.\n256-bit unsigned integer\nV0 of the segment header data structure\nS-bucket 0.\nPiece index 0.\nPiece index 0.\nSegment index 0.\nProgress of an archived block.\nReturns the slice of the entries.\nBidirectional distance metric implemented on top of …\nAdds two numbers, checking for overflow. If overflow …\nDivides two numbers, checking for underflow, overflow and …\nMultiplies two numbers, checking for underflow or …\nChecked integer subtraction. Computes <code>self - rhs</code>, …\nSubtracts two numbers, checking for underflow. If …\nModule containing wrapper for SCALE encoding/decoding with …\nChunk at above offset\nWitness for above chunk\nCommitment contained within a piece.\nMutable commitment contained within a piece.\nVarious cryptographic utilities used across Subspace …\nWe assume a block can always fit into the segment …\nDerive evaluation seed\nDerive history size when sector created at <code>history_size</code> …\nDerive global slot challenge from global randomness.\nDerives the global randomness from the output\nDerive piece index that should be stored in sector at …\nDerive sector slot challenge for this sector from provided …\nReturns the first entry.\nGet the first piece index in this segment.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate from big endian bytes\nCreate piece index from bytes.\nDerive initial PoT seed from genesis block hash\nCreate from little endian bytes\nDummy solution for the genesis block\nProof hash.\nPublic key hash.\nHash of the whole segment header\nSize of the blockchain history at time of sector creation\nSize of blockchain history in pieces.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTransform solution with one reward address type into …\nReturns an iterator for the entries.\nReturns a mutable iterator for the entries.\nDerive key from proof of time seed\nReturns the last entry.\nLast archived block\nGet the last piece index in this segment.\nReturns the number of entries.\nAllocate <code>FlatPieces</code> that will hold <code>piece_count</code> pieces …\nCreate new instance\nCreate new instance.\nCreate new sector ID by deriving it from public key and …\nCreates the Vec.\nCreate boxed value without hitting stack overflow\nCreate boxed value without hitting stack overflow\nCreate boxed value without hitting stack overflow\nCreate boxed value without hitting stack overflow\nCreates the Vec with the entry.\nCreate vector filled with zeroe records without hitting …\nBlock number\nData structures related to objects (useful data) stored on …\nOne (multiplicative identity) of this type.\nGet proof of time output out of checkpoints (last …\nParallel iterator over parity pieces (odd indices)\nMutable parallel iterator over parity pieces (odd indices)\nParallel iterator over source pieces (even indices)\nMutable parallel iterator over source pieces (even indices)\nIterator over parity pieces (odd indices)\nMutable iterator over parity pieces (odd indices)\nIterator over parity pieces (odd indices)\nReturn the number of partially archived bytes if the …\nReturns the number of partially archived bytes for a block.\nPieces offset within sector\nIterate over all pieces.\nPosition of a piece in a segment\nHash of the segment header of the previous segment\nProof of space for piece offset\nPublic key of the farmer that created the solution\nAdds an entry to the end.\nRecord contained within a piece.\nRecord commitment that can use used to verify that piece …\nMutable record contained within a piece.\nWitness for above record commitment\nAddress for receiving block reward\nIndex of s-bucket within sector to be audited\nSaturating addition. Computes <code>self + other</code>, saturating at …\nSaturating multiplication. Computes <code>self * other</code>, …\nSaturating subtraction. Computes <code>self - other</code>, saturating …\nHistory size at which expiration check for sector happens.\nIndex of the sector where solution was found\nComputes the following:\nDerive seed from proof of time in case entropy injection …\nDerive seed from proof of time with entropy injection\nSegment commitment of the records in a segment.\nSegment index piece index corresponds to\nSegment index that corresponds to this history size.\nSegment index\nList of piece indexes that belong to this segment.\nList of piece indexes that belong to this segment with …\nSets the archived state of this block to …\nSets new number of partially archived bytes.\nSets new number of partially archived bytes.\nConvenient conversion from slice of underlying …\nConvenient conversion from slice of underlying …\nConvenient conversion from slice of underlying …\nConvenient conversion from mutable slice of underlying …\nConvenient conversion from mutable slice of underlying …\nConvenient conversion from mutable slice of underlying …\nConvenient conversion from mutable slice of record to …\nConvenient conversion from mutable slice of record to …\nConvenient conversion from mutable slice of piece array to …\nConvenient conversion from slice of record to underlying …\nConvenient conversion from slice of record to underlying …\nConvenient conversion from slice of piece array to …\nComputes the following:\nIterator over source pieces (even indices)\nMutable iterator over source pieces (even indices)\nIterator over source pieces (even indices)\nSplit piece into underlying components.\nSplit piece into underlying mutable components.\nConvert to big endian bytes\nConvert piece index to bytes.\nConvert piece offset to bytes.\nConvert to little endian bytes\nEnsure piece contains cheaply cloneable shared data.\nEnsure flat pieces contains cheaply cloneable shared data.\nEnsure archived history segment contains cheaply cloneable …\nReturns the entries in the collection.\nWitness contained within a piece.\nMutable witness contained within a piece.\nZero (additive identity) of this type.\nLast archived block\nHash of the segment header of the previous segment\nRoot of commitments of all records in a segment.\nSegment index\nWrapper data structure that when encoded/decoded will …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nHow many bytes Scalar contains physically, use …\nHow many full bytes can be stored in BLS12-381 scalar (for …\nRepresentation of a single BLS12-381 scalar value.\nBLAKE3 hashing of a single value truncated to 254 bits.\nBLAKE3 hashing of a single value.\nBLAKE3 hashing of a list of values.\nBLAKE3 hashing of a single value in parallel (only useful …\nBLAKE3 keyed hashing of a single value.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTools for KZG commitment scheme\nConvenient conversion from slice of underlying …\nConvenient conversion from mutable slice of underlying …\nConvenient conversion from mutable slice of scalar to …\nConvenient conversion from slice of optional underlying …\nConvenient conversion from optional mutable slice of …\nConvenient conversion from optional mutable slice of …\nConvenient conversion from slice of optional scalar to …\nConvenient conversion from slice of scalar to underlying …\nConvert scalar into bytes\nConvenient conversion from vector of underlying …\nConvenient conversion from vector of optional underlying …\nConvenient conversion from vector of optional scalar to …\nConvenient conversion from vector of scalar to underlying …\nCommitment to polynomial\nEmbedded KZG settings as bytes, too big for <code>no_std</code> in most …\nWrapper data structure for working with KZG commitment …\nNumber of G1 powers stored in <code>EMBEDDED_KZG_SETTINGS_BYTES</code>\nNumber of G2 powers stored in <code>EMBEDDED_KZG_SETTINGS_BYTES</code>\nCommitment to polynomial\nWitness for polynomial evaluation\nFunction turns bytes into <code>FsKZGSettings</code>, it is up to the …\nComputes a <code>Commitment</code> to <code>polynomial</code>\nComputes a <code>Witness</code> of evaluation of <code>polynomial</code> at <code>index</code>\nEmbedded KZG settings\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet FFT settings for specified number of values, uses …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate new instance with given KZG settings.\nNormalize polynomial by removing trailing zeroes\nCreate polynomial from data. Data must be multiple of 32 …\nConvenient conversion from slice of underlying …\nConvenient conversion from mutable slice of underlying …\nConvenient conversion from mutable slice of commitment to …\nConvenient conversion from slice of optional underlying …\nConvenient conversion from optional mutable slice of …\nConvenient conversion from optional mutable slice of …\nConvenient conversion from slice of optional commitment to …\nConvenient conversion from slice of commitment to …\nConvert commitment to raw bytes\nConvert witness to raw bytes\nTry to deserialize commitment from raw bytes\nTry to deserialize witness from raw bytes\nConvenient conversion from vector of underlying …\nConvenient conversion from vector of optional underlying …\nConvenient conversion from vector of optional commitment …\nConvenient conversion from vector of commitment to …\nVerifies that <code>value</code> is the evaluation at <code>index</code> of the …\nObject stored inside of the block\nMapping of objects stored inside of the block\nObject stored inside in the history of the blockchain\nObject stored inside of the block\nMapping of objects stored inside of the piece\nV0 of object mapping data structure\nV0 of object mapping data structure\nV0 of object mapping data structure\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nObject hash\nObject hash\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nObjects stored inside of the block\nObjects stored inside of the block\nOffset of object in the encoded block.\nOffset of the object\nOffset of the object\nPiece index where object is contained (at least its …\nSets new offset.\nObject hash\nOffset of object in the encoded block.\nOffset of the object\nPiece index where object is contained (at least its …\nObject hash\nOffset of the object")